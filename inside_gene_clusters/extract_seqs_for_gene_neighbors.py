#!/usr/bin/python
import sys, getopt
import json
import collections


# It is important to put this script together with prepareNamesAndFetch.py script.
USAGE = "\n\nThe extract sequences processing JSON file with the neighbors generated by TREND.\n\n" + \
	"It is important to put this script together with prepareNamesAndFetch.py script. \n\n" + \
	"python 	" + sys.argv[0] + '''
	-h || --help               - help
	-i || --ifile              - input file with gene neighbors information in json format
	-s || --sfile              - protein ids 
	-p || --inoperons          - cluster directons confined to operons or not: "yes" or "no". Default is "yes"
	-t || --tolerance          - number of unshared genes (their cluster ids based on shared domains) insdie directons
	                           for two directons still be considered as members of the same directon. The max number
	                           of unsahared genes from comparing two sets is taken to compare to this value.
	-o || --ofile              - output file with the sequences in fasta format
	'''

INPUT_FILE = None
PROTEIN_IDS_FILE = None
OUTPUT_FILE = None

MAIN_PROTEIN_TO_NEIGHBORS_AND_SELF = {}
PROTEIN_IDS = set()
UNSHARED_ELEMENTS_TOLERANCE = 0
IN_OPERONS = True
ORDERED_NEIGHBORS = True

def initialize(argv):
	global INPUT_FILE, OUTPUT_FILE, PROTEIN_IDS_FILE, IN_OPERONS, UNSHARED_ELEMENTS_TOLERANCE, NUM_OF_NEIGHBORING_GENES
	try:
		opts, args = getopt.getopt(argv[1:],"hi:o:s:p:t:",["help", "ifile=", "ofile=", "sfile=", "inoperons=", "tolerance="])
		if len(opts) == 0:
			raise getopt.GetoptError("Options are required\n")
	except getopt.GetoptError as e:
		print "===========ERROR==========\n " + str(e) + USAGE
		sys.exit(2)
	try:
		for opt, arg in opts:
			if opt in ("-h", "--help"):
				print USAGE
				sys.exit()
			elif opt in ("-i", "--ifile"):
				INPUT_FILE = str(arg).strip()
			elif opt in ("-o", "--ofile"):
				OUTPUT_FILE = str(arg).strip()
			elif opt in ("-s", "--sfile"):
				PROTEIN_IDS_FILE = str(arg).strip()
			elif opt in ("-p", "--inoperons"):
				val = str(arg).strip()
				if val == "false":
					IN_OPERONS = False
			elif opt in ("-t", "--tolerance"):
				UNSHARED_ELEMENTS_TOLERANCE = int(str(arg).strip())
	except Exception as e:
		print "===========ERROR==========\n " + str(e) + USAGE
		sys.exit(2)


def loadClusterIds():
	with open(PROTEIN_IDS_FILE, "r") as protIdsFile:
		for protId in protIdsFile:
			PROTEIN_IDS.add(protId.strip())

def loadJSON():
	try:
		with open(INPUT_FILE, "r") as inputFile:
			result = json.loads(inputFile.read())
	except Exception as e:
		result = None
		print("Exception happened whyle trying to decode json: " + str(e))
		print("So returning None")
	finally:
		return result
	
'''
1) Cluter directons that are confined to operons based on the gene clusters
a) Identify all the neighboring genes in the operon (set based on the intergene distance) and extract them
b) Make a collection of cluster ids
	aa) a set
	bb) a list
c) Compare (setting first a hreshold of the number of not shared genes (cluster ids) for the directons still to be considered as members
of the same directon cluster) cluster id collection of the next processed directon to the previous one and decide do they
belong the the same directon cluster

2) Cluster directons that are not confined to openors based on gene clusters.
a) Just define the number of neighboring genes in the cluster and work with them.
Other steps are the same.
'''

def clusterDirectonsRegardlessOfOperons(result):
	mainProteinToGeneClstrIds = collections.defaultdict(set)	
	# Creating a map of main protein to operonic gene cluster ids collection
	for protein, neighbors in result.items():
		if neighbors[-1]["version"] != None and neighbors[-1]["version"] in PROTEIN_IDS:
			mainProteinStrand = protein["strand"]
			for neighbor in neighbors[:-1]:
				if neighbor["version"] != None and neighbor["strand"] == mainProteinStrand:
					mainProteinToGeneClstrIds[protein].add(neighbor["clusterId"])
	return clusterDirectons(mainProteinToGeneClstrIds)
	
	
def clusterDirectonsInOperons(result):
	mainProteinToOperonicGeneClstrIds = collections.defaultdict(set)	
	# Creating a map of main protein to operonic gene cluster ids collection
	for protein, neighbors in result.items():
		if neighbors[-1]["version"] != None and "operon" in neighbors[-1] and neighbors[-1]["version"] in PROTEIN_IDS:
			mainGeneOperonId = int(neighbors[-1]["operon"])
			protNum = int(protein.split("_")[0])
			for neighbor in neighbors[:-1]:
				if neighbor["version"] != None and "operon" in neighbor \
					and int(neighbor["operon"]) == mainGeneOperonId and "clusterId" in neighbor: 
						mainProteinToOperonicGeneClstrIds[protein].add(neighbor["clusterId"])
	return clusterDirectons(mainProteinToOperonicGeneClstrIds)


# Actual clustering of directons
def clusterDirectons(proteinToGeneClstrIds):					
	clusterNumberToMainProteinIds = collections.defaultdict(list)
	directonClsCounter = 0
	processedIds = set()
	for protein, clstIds in proteinToGeneClstrIds.items():
		if protein not in processedIds:
			for protein2, clstIds2 in proteinToGeneClstrIds.items():
				if protein != protein2 and protein2 not in clusterNumberToMainProteinIds[directonClsCounter] \
					and protein2 not in processedIds:
					differenceSet1 = clstIds - clstIds2
					differenceSet2 = clstIds2 - clstIds
					unsharedElementsNum = max(len(differenceSet1), len(differenceSet2))					
					if len (clstIds2 ^ clstIds) > 0 and unsharedElementsNum <= UNSHARED_ELEMENTS_TOLERANCE:
						if protein not in clusterNumberToMainProteinIds[directonClsCounter]:
							clusterNumberToMainProteinIds[directonClsCounter].append(protein)
							processedIds.add(protein)
						clusterNumberToMainProteinIds[directonClsCounter].append(protein2)
						processedIds.add(protein2)
			if len(clusterNumberToMainProteinIds[directonClsCounter]):
				directonClsCounter +=1
	return clusterNumberToMainProteinIds


def saveToFile(clusterNumberToMainProteinIds):
	with open(OUTPUT_FILE, "w")	as outputFile:
		for clstNumber, proteinIds in clusterNumberToMainProteinIds.items():
			for proteinId in proteinIds:
				outputFile.write(str(clstNumber) + "\t" + proteinId + "\n")
						

def main(argv):
	initialize(argv)
	loadClusterIds()
	result = loadJSON()
	if result != None:
		print ("Decoded JSON file OK.")
		print ("Clustering directons ...")
		if IN_OPERONS:
			clusterNumberToMainProteinIds = clusterDirectonsInOperons(result)
		else:
			clusterNumberToMainProteinIds = clusterDirectonsRegardlessOfOperons(result)
		print ("Finished clustering directons.")
		print ("Saving to the provided output file.")
		saveToFile(clusterNumberToMainProteinIds)
		print ("Saved to the file.")


if __name__ == "__main__":
	main(sys.argv)
